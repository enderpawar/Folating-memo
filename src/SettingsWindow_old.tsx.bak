import { useState, useEffect } from 'react';
import './SettingsWindow.css';

interface StickyNote {
  id: number;
  content: string;
  positionX: number;
  positionY: number;
  width: number;
  height: number;
  createdAt: string;
}

declare global {
  interface Window {
    electronAPI?: {
      createNote: (noteData: any) => Promise<StickyNote>;
      getAllNotes: () => Promise<StickyNote[]>;
      deleteNote: (noteId: number) => Promise<void>;
      updateNote: (noteId: number, updates: any) => Promise<StickyNote>;
      onNoteCreated: (callback: (note: StickyNote) => void) => void;
      onNoteUpdated: (callback: (note: StickyNote) => void) => void;
      onNoteDeleted: (callback: (noteId: number) => void) => void;
      isElectron: boolean;
    };
  }
}

export default function SettingsWindow() {
  const [notes, setNotes] = useState<StickyNote[]>([]);
  const [username, setUsername] = useState('User');

  // ì´ˆê¸° ë…¸íŠ¸ ë¡œë“œ
  useEffect(() => {
    if (window.electronAPI) {
      loadNotes();
      
      // ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      window.electronAPI.onNoteCreated((note) => {
        setNotes(prev => [...prev, note]);
      });
      
      window.electronAPI.onNoteUpdated((note) => {
        setNotes(prev => prev.map(n => n.id === note.id ? note : n));
      });
      
      window.electronAPI.onNoteDeleted((noteId) => {
        setNotes(prev => prev.filter(n => n.id !== noteId));
      });
    }
  }, []);

  const loadNotes = async () => {
    if (window.electronAPI) {
      const allNotes = await window.electronAPI.getAllNotes();
      setNotes(allNotes);
    }
  };

    // ê¸°ì¡´ ë…¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°
    axios.get<StickyNote[]>('http://localhost:8080/api/notes')
      .then(response => setNotes(response.data))
      .catch(error => console.error('Failed to load notes:', error));

    return () => {
      client.deactivate();
    };
  }, []);

  // ì‚¬ìš©ìëª… ì„¤ì •
  useEffect(() => {
    const name = localStorage.getItem('username') || `User${Math.floor(Math.random() * 1000)}`;
    setUsername(name);
    localStorage.setItem('username', name);
  }, []);

  // í´ë¦½ë³´ë“œ ë¶™ì—¬ë„£ê¸°
  const handlePaste = async (e: React.ClipboardEvent) => {
    const items = e.clipboardData?.items;
  // ë“œë˜ê·¸ & ë“œë¡­ ì²˜ë¦¬
  const handleDrop = async (e: React.DragEvent) => {
    e.preventDefault();
    
    const items = e.dataTransfer.items;
    if (!items) return;

    for (const item of Array.from(items)) {
      if (item.type.startsWith('image/')) {
        const file = item.getAsFile();
        if (file) {
          const reader = new FileReader();
          reader.onload = async (event) => {
            const base64 = event.target?.result as string;
            await createNote(base64);
          };
          reader.readAsDataURL(file);
        }
      } else if (item.type === 'text/plain') {
        item.getAsString(async (text) => {
          await createNote(text);
        });
      }
    }
  };

  // ë…¸íŠ¸ ìƒì„±
  const createNote = async (content: string) => {
    if (!window.electronAPI) return;
    
    const noteData = {
      content,
      positionX: Math.random() * (window.screen.width - 300),
      positionY: Math.random() * (window.screen.height - 300),
      width: 300,
      height: 200
    };

    try {
      const newNote = await window.electronAPI.createNote(noteData);
      // ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
      console.log('Note created:', newNote);
    } catch (error) {
      console.error('Failed to create note:', error);
    }
  };

  // ë…¸íŠ¸ ì‚­ì œ
  const handleDelete = async (id: number) => {
    if (!window.electronAPI) return;
    
    try {
      await window.electronAPI.deleteNote(id);
      // ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ë¡œ ìë™ ì—…ë°ì´íŠ¸ë¨
    } catch (error) {
      console.error('Failed to delete note:', error);
    }
  };
    } catch (error) {
      console.error('Failed to delete note:', error);
    }
  };

  // ì½”ë©˜íŠ¸ ë¡œë“œ
  const loadComments = async (noteId: number) => {
    try {
      const response = await axios.get<Comment[]>(`http://localhost:8080/api/comments/note/${noteId}`);
      setComments(prev => ({
        ...prev,
        [noteId]: response.data
  return (
    <div className="settings-window" onPaste={handlePaste}>
      <div className="header">
        <h1>ğŸ¯ Sticky Board</h1>
        <p>Ctrl+Vë¡œ í´ë¦½ë³´ë“œì˜ ì´ë¯¸ì§€ë‚˜ í…ìŠ¤íŠ¸ë¥¼ ë°”íƒ•í™”ë©´ì— ë„ìš°ì„¸ìš”!</p>
      </div>

      <div className="content">
        <div className="notes-grid">
          <h2>í¬ìŠ¤íŠ¸ì‡ ëª©ë¡ ({notes.length}ê°œ)</h2>
          <div className="grid">
            {notes.map(note => (
              <div 
                key={note.id} 
                className="note-card"
                onClick={() => handleNoteClick(note)}
              >
                {note.type === 'IMAGE' ? (
                  <img src={note.content} alt="note" />
                ) : (
                  <p>{note.content}</p>
                )}
                <button 
                  className="delete-btn"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleDelete(note.id);
                  }}
                >
                  Ã—
                </button>
                <div className="note-info">
                  <span>{note.createdBy}</span>
                </div>
              </div>
            ))}
          </div>
        </div>

        {selectedNote && (
          <div className="comments-panel">
            <h2>ì½”ë©˜íŠ¸</h2>
            <div className="comments-list">
              {(comments[selectedNote.id] || []).map((comment, idx) => (
                <div key={idx} className="comment">
                  <strong>{comment.author}</strong>: {comment.content}
                  {comment.createdAt && (
                    <span className="time">
                      {new Date(comment.createdAt).toLocaleString()}
                    </span>
                  )}
                </div>
              ))}
            </div>
            <div className="comment-input">
              <input
                type="text"
                value={newComment}
                onChange={(e) => setNewComment(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleAddComment()}
                placeholder="ì½”ë©˜íŠ¸ ì…ë ¥..."
              />
              <button onClick={handleAddComment}>ì „ì†¡</button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
